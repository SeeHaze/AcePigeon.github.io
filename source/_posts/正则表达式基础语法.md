# 正则表达式参考

Created By: Moyuu Fun
Last Edited: Dec 21, 2019 4:01 PM
Tags: RegExp, 正则表达式

## **元字符**

| 代码  |  说明                                                        |
| ---- |   ----                                                        |
|  .   |   匹配除换行符以外的任意字符                                    |
|  \w  |   匹配字母或数字或下划线或汉字                                  |
|  \s  |   匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等  |
|  \d  |   匹配数字                                                     |
|  \b  |   匹配单词的开始或结束                                          |
|  ^   |   匹配字符串的开始                                             |
|  $   |   匹配字符串的结                                               |

例如：

```\ba\w*\b```匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。

```\d+```匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。

```\b\w{6}\b``` 匹配刚好6个字符的单词。

元字符^和$都匹配一个位置，这和\b有点类似。^匹配要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：```^\d{5,12}$```。

因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。

## **字符转义**

如果查找元字符本身的话，比如查找.,或者\*,就得使用```\```来取消这些字符的特殊意义。因此，使用```\.```和```\*```。当然，要查找\本身，也得用```\\```。

例如：```deerchao\.cn```匹配deerchao.cn，```C:\\Windows```匹配C:\Windows。

## **重复**

| 代码/语法 | 说明             |
| --------- | ---------------- |
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |

## **字符类**

要想查找数字、字母或数字等是很简单的，已经有了对应这些字符集合的元字符，

如果要匹配没有预定义元字符的字符集合，需要在方括号里列出它们

例如：

```[aeiou]```匹配任何一个英文元音字母

```[.?!]```匹配标点符号(.或?或!)

```[0-9]```等同于\d，表示一位数字

```[a-z0-9A-Z_]```匹配数字字母及下划线

## **分枝条件**

分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 ```|``` 把不同的规则分隔开

例如：

```0\d{2}-\d{8}|0\d{3}-\d{7}```

这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)

匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了，因此，**使用分枝条件时，要注意各个条件的顺序**

## **分组**

如果想要重复多个字符，可以用小括号来指定子表达式(也叫做分组)

例如：

```((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)```匹配IP地址

## **反义**

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |

例如：

```\S+```匹配不包含空白符的字符串。

```<a[^>]+>```匹配用尖括号括起来的以a开头的字符串

## **后向引用**

使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，```\1```代表分组1匹配的文本。

例：

```\b(\w+)\b\s+\1\b```可以用来匹配类似go go，ha ha的重复的单词

也可以指定子表达式的**组名**。

语法：```(?<name>exp)```，或者把尖括号换成'：```(?'name'exp)```

要反向引用这个分组**捕获**的内容，可以使用\k<name>

例如：

```\b(?<Word>\w+)\b\s+\k<Word>\b```

| 分类     | 代码/语法    | 说明                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
| 捕获     | (exp)        | 匹配exp,并捕获文本到自动命名的组里                           |
|          | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
|          | (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |
| 零宽断言 | (?=exp)      | 匹配exp前面的位置                                            |
|          | (?<=exp)     | 匹配exp后面的位置                                            |
|          | (?!exp)      | 匹配后面跟的不是exp的位置                                    |
|          | (?<!exp)     | 匹配前面不是exp的位置                                        |
| 注释     | (?#comment)  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |



## **零宽断言**

用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此被称为**零宽断言**。

例如：

1. ```(?=exp)```也叫**零宽度正预测先行断言**`(什么鬼？)`，它断言自身出现的位置的后面能匹配表达式exp。比如 ```\b\w+(?=ing\b)``` ，匹配以ing结尾的单词的前面部分(除了ing以外的部分)
2. ```(?<=exp)```也叫**零宽度正回顾后发断言**`(嘛玩意？)`，它断言自身出现的位置的前面能匹配表达式exp。比如 ```(?<=\bre)\w+\b``` 会匹配以re开头的单词的后半部分(除了re以外的部分)
3. ```(?<=\s)\d+(?=\s)```匹配以空白符间隔的数字(再次强调，不包括这些空白符)。

## **负向零宽断言**

如果只是想要**确保某个字符没有出现，但并不想去匹配它**时，我们可以尝试使用**负向零宽断言**

例如：

1. ```(?!exp)```也叫**零宽度负预测先行断言**`(你说啥？)`，断言此位置的后面不能匹配表达式exp。比如： ```\d{3}(?!\d)``` 匹配三位数字，而且这三位数字的后面不能是数字；```\b((?!abc)\w)+\b```匹配不包含连续字符串abc的单词。
2. ```(?<!exp)```也叫**零宽度负回顾后发断言**`(听不清！)`，断言此位置的前面不能匹配表达式exp。比如： ```(?<![a-z])\d{7}``` 匹配前面不是小写字母的七位数字。
3. ```(?<=<(\w+)>).*(?=<\/\1>)```匹配不包含属性的简单HTML标签内里的内容。```(?<=<(\w+)>)```指定了这样的**前缀**：被尖括号括起来的单词(比如可能是```<b>```)，然后是```.*```(任意的字符串),最后是一个**后缀**```(?=<\/\1>)```。注意后缀里的```\/```，它用到了前面提过的字符转义；```\1```则是一个反向引用，引用的正是捕获的第一组，前面的```(\w+)```匹配的内容，这样如果前缀实际上是```<b>```的话，后缀就是```</b>```了。整个表达式匹配的是```<b>```和```</b>```之间的内容(再次提醒，不包括前缀和后缀本身)。

## **注释**

小括号的另一种用途是通过语法```(?#comment)```来包含注释。例如：```2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)```。

## **贪婪与懒惰**

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：```a.*b```，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。

有时，更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号```?```。这样```.*?```就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

```a.*?b```匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| 代码/语法 | 说明                            |
| --------- | ------------------------------- |
| *?        | 重复任意次，但尽可能少重复      |
| +?        | 重复1次或更多次，但尽可能少重复 |
| ??        | 重复0次或1次，但尽可能少重复    |
| {n,m}?    | 重复n到m次，但尽可能少重复      |
| {n,}?     | 重复n次以上，但尽可能少重复     |



## **其他内容**

其他内容可以参考微软官方文档[关于正则表达式语言元素的MSDN在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)

| 代码/语法        | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| \a               | 报警字符(打印它的效果是电脑嘀一声)                           |
| \b               | 通常是单词分界位置，但如果在字符类里使用代表退格             |
| \t               | 制表符，Tab                                                  |
| \r               | 回车                                                         |
| \v               | 竖向制表符                                                   |
| \f               | 换页符                                                       |
| \n               | 换行符                                                       |
| \e               | Escape                                                       |
| \0nn             | ASCII代码中八进制代码为nn的字符                              |
| \xnn             | ASCII代码中十六进制代码为nn的字符                            |
| \unnnn           | Unicode代码中十六进制代码为nnnn的字符                        |
| \cN              | ASCII控制字符。比如\cC代表Ctrl+C                             |
| \A               | 字符串开头(类似^，但不受处理多行选项的影响)                  |
| \Z               | 字符串结尾或行尾(不受处理多行选项的影响)                     |
| \z               | 字符串结尾(类似$，但不受处理多行选项的影响)                  |
| \G               | 当前搜索的开头                                               |
| \p{name}         | Unicode中命名为name的字符类，例如\p{IsGreek}                 |
| (?>exp)          | 贪婪子表达式                                                 |
| (?<x>-<y>exp)    | 平衡组                                                       |
| (?im-nsx:exp)    | 在子表达式exp中改变处理选项                                  |
| (?im-nsx)        | 为表达式后面的部分改变处理选项                               |
| (?(exp)yes\|no)  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| (?(exp)yes)      | 同上，只是使用空表达式作为no                                 |
| (?(name)yes\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |
| (?(name)yes)     | 同上，只是使用空表达式作为no                                 |

